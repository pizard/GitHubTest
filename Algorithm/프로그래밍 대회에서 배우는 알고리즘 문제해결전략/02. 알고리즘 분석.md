# 4. 알고리즘의 시간 복잡도 분석
## 4.1 도입
- 속도 비교 방법1 : 프로그램의 수행 시간 측정
  - 사용하는 언어, 하드웨어, 운영체제, 컴파일러에 의해 바뀔 수 있음
  - 수행 시간이 다양한 입력에 대한 실행 시간을 반영하지 못함
-  반복문이 중요
## 4.2 선형 시간 알고리즘
- 이동 평균(moving average) : 주식 가격, GDP 등 시계열 데이터에 유용
  - M-이동 평균 : 마지막 M개의 평균
## 4.3 선형 이하 시간 알고리즘
- 선형 이하 시간(sublinear time) 알고리즘
  - 입력의 크기가 커지는 것보다 수행 시간이 느리게 증가하는 알고리즘
- 이진 탐색(binary search)
- 선형 시간 알고리즘과의 차이
  1. 데이터의 값들을 계산해서 갖고 있을 필요가 없음
  2. 사진을 정렬하는 과정과 검색하는 하는 과정은 별개임
## 4.4 지수 시간 알고리즘
- 다항 시간 알고리즘
  - 다항식 : N의 거듭 제곱들의 선형결합으로 이루어진 식(N, N^2, N^3.... )
  - 반복문의 수행 횟수를 입력 크기의 다항식으로 표현할 수 있는 알고리즘
- 지수 시간 알고리즘
  - N이 하나 증가할 때마다 걸리는 시간이 배로 증가하는 알고리즘(2^N)
- 소인수 분해의 수행 시간
  - 소수일 경우 반복문이 가장 많이 실행됨
## 4.5 시간 복잡도
- 시간복잡도(time complexity) : 알고리즘이 실행되는 동안 수행하는 기본적인 연산의 수를 입력의 크기에 대한 함수로 표현한
- 입력의 상태에 따른 수행 시간
  - 최선의 수행 시간
  - 최악의 수행시간
  - 평균적인 수행 시간
- 점근적 시간 표기 : O표기
  - 대문자 O 표기법(Big-O Notation)
- 시간 복잡도의 분할 상환 분석(amortized analysis)
  - N개의 작업을 순서대로 하는데, 각 작업에 걸리는 시간은 모두 다르지만 전체 작업에 걸리는 시간이 일정한 경우
## 4.6 수행 시간 어림짐작하기
## 4.7 계산 복잡도 클래스: P,NP, NP-완비
# 5. 알고리즘의 정당성 증명
## 5.1 도입
- 알고리즘의 정당성 증명
  - 문제가 복잡해지면 해당 알고리즘이 문제를 제대로  해결했는지를 파악하기 조차 까다로움
  - <b>알고리즘의 증명을 위해 흔히 사용되는 기법들을 다룸</b>
## 5.2 수학적 귀납법과 반복문 불변식
- 순서
  1. 단계 나누기
  2. 첫 단계 증명
  3. 귀납 증명
- 반복문 불변식
  - 반복문의 내용이 한 번 실행될 때마다 중간 결과가 원하는 값으로 가는 중인지 확인
- 삽입 정렬과 반복문 불변식
## 5.3 귀류법
## 5.4 다른 기술들
- 비둘기 집의 원리
- 동전 뒤집기....?
- 순호나 소수 찾기

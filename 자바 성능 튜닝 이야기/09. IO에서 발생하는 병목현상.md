# 09. IO에서 발생하는 병목현상
## IO vs NIO(New In/Out, Non Blocking I/O)
### 기본적인 IO는 이렇게 처리한다.
 - 스트림을 읽는데 관련된 주요 클래스
 - java.io.InputStream 클래스로부터 상속
 	 - ByteArrayInputStream: 바이트로 구성된 배열을 읽어 입력 스트림으로 만듬
 	 - FileInputStream: 이미지와 같은 바이너리 기반의 파일 스트림을 만듬
 	 - FilterInputStream: 여러 종류의 유용한 입력 스트림의 추상 클래스
 	 - ObjectInputStream: ObjectOutputStream을 통해서 저장해 놓은 객체를 읽기 위한 스트림을 만듬
 	 - PipedInputStream: PipedOutputStream을 통해서 출력된 스트림을 읽어서 처리하기 위한 스트림을 만듬
 	 - SequenceInputStream: 별개의 두 스트림을 하나의 스트림으로 만든다.

 - 문자열 기반의 스트림을 읽기 위해서 사용하는 클래스
 - java.io.Reader 클래스로부터 상속
 	 - BufferedReader: 문자열 입력 스트림을 버퍼에 담아서 처리
 	 - CharArrayReader: char의 배열로 된 문자 배열을 처리함
 	 - FilterReader: 문자열 기반의 스트림을 처리하기 위한 추상 클래스
 	 - FileReader: 문자열 기반의 파일을 읽기 윟나 클래스
 	 - InputStreamReader: 바이트 기반의 스트림을 문자열 기반의 스트림으로 연결하는 역할을 수행
 	 - PipedReader: 파이프 스트림을 읽는다.
 	 - StringReader: 문자열 기반의 소스를 읽는다.
 - 바이트 단위로 읽거나 문자열 단위로 읽거나 중요한 것은 한 번 연(open한) 스트림은 반드시 닫아주어야 한다.
 	 - 이 거 자바 뭐 있었는데 익셉션

### IO에서 병목이 발생한 사례


### 그럼 NIO의 원리는 어떻게 되는 거지?
 - IO작업이 운영체제에서 수행되는 방법
 	 1. 여러분이 파일을 읽으라는 메서드를 자바에 전달
 	 2. 파일명을 전달받은 메서드가 운영체제의 커널에게 파일을 읽어 달라고 요청
 	 3. 커널이 하드 디스크로부터 파일을 읽어서 자신의 커널에 있는 버퍼에 복사, DMA에서 이 작업 수행
 	 4. 자바에서는 마음대로 커널의 버퍼를 사용하지 못하므로, JVM으로 그 데이터를 전달
 	 5. JVM에서 메서드에 있는 스트림 관리 클래스를 사용하여 데이터를 처리
 	 - 이떄 3번의 복사작업이나 4번의 전달 작업에서 대기시간이 발생할 수 밖에 없는데 이런 단점을 보완하기 위해 NIO가 탄생
 	 - 3번의 작업을 자바에서 직접 통제할 수 있도록 하여 시간 단축
 	
 - 새롭게 추가된 개념
 	 - 버퍼의 도입
 	 - 채널의 도입
 	 - 문자열의 인코더와 디코더 제공
 	 - Perl 스타일의 정규 표현식에 기초한 패턴 매칭 방법 제공
 	 - 파일을 잠그거나 메모리 매핑이 가능한 파일 인터페이스 제공
 	 - 서버를 위한 복합적인 Non-blocking IO 제공

### DirectByteBuffer를 잘못 사용하여 문제가 발생한 사례
 - ** 여기서 부터는 읽어도 모르는 내용이 꽤 많아서 일단 공부할 것 먼저 공부하고 다시 읽어야...**


### 더 공부할 것
 - NIO..?
 - 채널이 뭐지?
 - IO작업이 운영체제에서 수행되는 법?
 - 흠... 커널의 개념도 좀 자세히 알고 싶은데 방대할거 같긴한데...
 - Blocking..?
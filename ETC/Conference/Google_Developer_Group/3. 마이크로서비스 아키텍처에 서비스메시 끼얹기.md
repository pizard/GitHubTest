# 3. 마이크로서비스 아키텍처에 서비스메시 끼얹기
## a. 생산성에 대하여
* 문제점
    * 복잡한 소스 구조
    * 느린 빌드
    * 오래 걸리는 테스트 코드 + QA
    * 개발도구 느려짐
    * 라이브러리 / 프레임워크 업데이트 힘듬
    * 단일 언어 / 단일 프레임워크
* 해결법
    1. 더 정교한 프로젝트 설계
    2. 서버리스 (Serverless)
    3. **마이크로서비스 아키텍처(MSA) √**
        - Monolith ➔ MicroServices

## b. 마이크로서비스와 서비스메시 + Istio 데모
* 마이크로서비스
    * 현실
        * 서비스가 분리되고 서로 호출은 하지만 관리는 안되는...ㅜ
    * Pros
        * 잘 설계된 서비스
        * 자동화 프로세스
        * 모니터링/로킹/알람
        * DevOps
    * Cons
        * 한 개의 문제가 있다고 해서 전체 서비스에 문제가 발생하진 않음 ➔ 하루동안 확인하지 못함
        * 각 서비스 별로 로그를 봐야함
        * 팀간으로 쪼개져서 서비스를 만듬 ➔ 소통이 힘듬
        * 운영/배포 한땀 한땀 손으로...
        * 넘치는 버그 / 디버깅 불가
        * 트랜잭션 오류
        * 자주 바뀌는 버전 및 명세
* 왜 서비스메시인가?
    * ex)
        * E-commerce + 추천시스템(합체, 단일시스템)
        * E-commerce / 추천시스템(분리, 분산컴퓨팅, Http 클리이언트를 통해 요청)
        * **네트워크 이슈 발생**
    * 분산 컴퓨팅에 대한 착오
        * 네트워크는 신뢰할 수 있다.
        * 레이턴시는 없다.
        * 대역폭은 무제한이다.
        * 네트워크는 안전하다.
        * 네트워크의 구성은 변하지 않는다.
        * 관리자는 한사람이다.
    * 그럼 여기서 네트워크는..?(Architecture)
        1. 서킷브레이커
            * a➔b로의 호출에서 b에 장애가 발생하고 딜레이를 준다면 a도 함께 성능저하가 발생함
            * 이에대해 문제가 발생할때 잠시동안 b로 요청을 보내지 않고 예비 결과 값을 리턴함
            * 수 초 후 다시 요청을 보내서 문제가 없으면 정상적으로 동작
        2. 재시도
            * 내부 코드상으로 재시도
        3. 로드밸런서
        4. 서비스 디스커버리
            * 서비스가 늘어날때마다 그것에 대한 ID를 로드밸런서에 알려줌
        5. 비율
            * 각 트래픽을 새로운 서비스가 들어왔을떄 조금 씩줬다가 괜찮으면 비율을 늘리는 기술
        6. 로그
        7. 대시보드
    * 구현방법(Retry)
        * 그럼 만약 재시도라는 기능에 대해 수정이 생긴다면..?
            * 프로그램 별로, 언어별로 모두 수정을 해 줘야한다는 한계가 있음
        * 그렇다면 코드를 사용하지 않고 프록시를 사용하면 어떨까..?
            * 프록시를 통해 요청과 응답
            * 프록시 내부에 Retry기능을 넣으면 반복되는 코드를 쓰지 않아도 괜찮음
            * 직접적인 통신이 아닌 서비스 옆의 프록시가 통신을 하게 됨
    * 발전 과정
        1. LINKERD
            * JVM/scala
            * salesforce, Paypal, Expedia, Fox AOL등에서 사용
            * 최근 Rust를 통해 2.0발표
        2. envoy
            * 더 작고 더 빠르게
            * 우버(Lyft)에서 C++을 사용하여 개발
        3. **Istio**
            * 더 편리하게
            * Google, IBM, Lyft에서 개발
            * kubernates 연동
            * 컨테이너기반, 클라우드 기반
            * envoy를 사용, 중앙에서 프록시 관리함

    * Istio의 기능
        1. Routing Management(경로 관리)
            * Header를 통해 분기(안드로이드, IOS)
            * 비율 관리
        2. Fault Injection(오류 주입)
        3. Security(보안)
            * Envoy - Envoy간 통신시 자동 암호화
        4. Distributed Tracing(분산 추적)
            * 여러 개의 서비스에서 시간 모니터링 기능
        5. Monitoring(모니터링)
            * Promemtheus
        6. Observability(feat. Kiali)
            * 현재 서비스가 어떻게 돌아가고 있는지, 어떤 서비스에서 어떤 문제가 발생했는지
            * 각 서비스를 Graph 형태로 보여줌
    * Isto Demo
        * https://github.com/subicura/istio-demo
        * inject 명령어로 proxy 주입
        * Add on
            * Graphana
            * Jagger (예거)

## c. 결론
* 비즈니스로직 + **인프라로직**
    * 인프라로직, 안정적인 운영에 대해서 앱에 넘겨줄 수 있음
    * 개발자는 개발만 집중하는 걸로...
* 넷플릭스 OSS에서 지원하는 기능을 완전히 다른 방식으로 제공
* 마이크로서비스에서 클라우드 네이티브 아키텍처로
* Docker -> kuberntest(도커 관리) -> Istio(분산된 컨테이너 관리)
* 어떤 언어에 종속적이지 않음

## d. Q/A
* Q) 전체 작업의 시간은 어느정도 걸렸는지
    * A) 기본적으로 제공하는 데이터가 있었고 수정에 대해서는 큰 어려움이 없이 바로바로
* Q) 버전 문제가 많았었는데 버전은 어땠는지
    * A) 도커/Istio/Kubernatics 모두 최신 버전을 사용하였음
